#!/usr/bin/env python3
"""
Web Application Vulnerability Scanner
Comprehensive web application security testing tool
"""

import subprocess
import sys
import json
import requests
import threading
from urllib.parse import urljoin, urlparse
import time
import re
import ssl
import socket

class WebVulnScanner:
    def __init__(self, target):
        self.target = target.rstrip('/')
        self.results = {
            "ssl_vulnerabilities": [],
            "security_headers": [],
            "information_disclosure": [],
            "authentication_issues": [],
            "session_management": [],
            "input_validation": [],
            "configuration_issues": [],
            "server_vulnerabilities": []
        }

    def log_output(self, message):
        print(f"[WEB_VULN_SCANNER] {message}")

    def check_ssl_configuration(self):
        """Check SSL/TLS configuration"""
        try:
            self.log_output("Checking SSL/TLS configuration...")
            
            parsed_url = urlparse(self.target)
            if parsed_url.scheme == "https":
                hostname = parsed_url.hostname
                port = parsed_url.port or 443
                
                # Check SSL certificate
                context = ssl.create_default_context()
                with socket.create_connection((hostname, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cert = ssock.getpeercert()
                        
                        # Check certificate validity
                        not_after = cert.get('notAfter')
                        if not_after:
                            self.results["ssl_vulnerabilities"].append({
                                "type": "Certificate Expiry",
                                "details": f"Certificate expires: {not_after}",
                                "severity": "Info"
                            })
                
                # Check for weak TLS versions
                try:
                    # Try to connect with TLS 1.0 (should fail on secure servers)
                    context_weak = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
                    with socket.create_connection((hostname, port), timeout=5) as sock:
                        with context_weak.wrap_socket(sock, server_hostname=hostname) as ssock:
                            self.results["ssl_vulnerabilities"].append({
                                "type": "Weak TLS Version",
                                "details": "TLS 1.0 is supported (deprecated)",
                                "severity": "Medium"
                            })
                except:
                    # Good - TLS 1.0 is not supported
                    pass
                
        except Exception as e:
            self.log_output(f"SSL check error: {str(e)}")

    def check_security_headers(self):
        """Check for security headers"""
        try:
            self.log_output("Checking security headers...")
            
            response = requests.get(self.target, timeout=10, verify=False)
            headers = response.headers
            
            # Define expected security headers
            security_headers = {
                "X-Frame-Options": {
                    "expected": ["DENY", "SAMEORIGIN"],
                    "description": "Prevents clickjacking attacks"
                },
                "X-Content-Type-Options": {
                    "expected": ["nosniff"],
                    "description": "Prevents MIME type sniffing"
                },
                "X-XSS-Protection": {
                    "expected": ["1; mode=block"],
                    "description": "Enables XSS filtering"
                },
                "Strict-Transport-Security": {
                    "expected": ["max-age="],
                    "description": "Enforces HTTPS connections"
                },
                "Content-Security-Policy": {
                    "expected": ["default-src"],
                    "description": "Prevents XSS and data injection"
                },
                "Referrer-Policy": {
                    "expected": ["strict-origin-when-cross-origin", "no-referrer"],
                    "description": "Controls referrer information"
                },
                "Permissions-Policy": {
                    "expected": ["geolocation=", "microphone="],
                    "description": "Controls browser features"
                }
            }
            
            for header_name, config in security_headers.items():
                if header_name not in headers:
                    self.results["security_headers"].append({
                        "type": "Missing Security Header",
                        "header": header_name,
                        "description": config["description"],
                        "severity": "Medium"
                    })
                else:
                    header_value = headers[header_name]
                    is_valid = any(expected in header_value for expected in config["expected"])
                    
                    if not is_valid:
                        self.results["security_headers"].append({
                            "type": "Weak Security Header",
                            "header": header_name,
                            "current_value": header_value,
                            "description": config["description"],
                            "severity": "Low"
                        })
            
            # Check for information disclosure headers
            disclosure_headers = ["Server", "X-Powered-By", "X-AspNet-Version", "X-AspNetMvc-Version"]
            for header in disclosure_headers:
                if header in headers:
                    self.results["information_disclosure"].append({
                        "type": "Information Disclosure",
                        "header": header,
                        "value": headers[header],
                        "description": f"Server information disclosed via {header} header",
                        "severity": "Low"
                    })
            
        except Exception as e:
            self.log_output(f"Security headers check error: {str(e)}")

    def check_authentication_issues(self):
        """Check for authentication-related issues"""
        try:
            self.log_output("Checking authentication issues...")
            
            # Check for common login pages
            login_paths = [
                "/login", "/admin", "/administrator", "/wp-admin", "/wp-login.php",
                "/admin.php", "/login.php", "/signin", "/sign-in", "/auth", "/panel"
            ]
            
            for path in login_paths:
                try:
                    url = urljoin(self.target, path)
                    response = requests.get(url, timeout=5, allow_redirects=False)
                    
                    if response.status_code in [200, 301, 302]:
                        self.results["authentication_issues"].append({
                            "type": "Admin Panel Accessible",
                            "url": url,
                            "status_code": response.status_code,
                            "description": "Admin/login panel found",
                            "severity": "Info"
                        })
                        
                        # Check for default credentials (basic test)
                        if response.status_code == 200:
                            content = response.text.lower()
                            if "username" in content and "password" in content:
                                # Try basic brute force protection test
                                login_data = {"username": "admin", "password": "admin"}
                                try:
                                    login_response = requests.post(url, data=login_data, timeout=5)
                                    if "invalid" not in login_response.text.lower() and "error" not in login_response.text.lower():
                                        self.results["authentication_issues"].append({
                                            "type": "Potential Default Credentials",
                                            "url": url,
                                            "description": "Login may accept weak credentials",
                                            "severity": "High"
                                        })
                                except:
                                    pass
                except:
                    continue
            
        except Exception as e:
            self.log_output(f"Authentication check error: {str(e)}")

    def check_session_management(self):
        """Check session management security"""
        try:
            self.log_output("Checking session management...")
            
            response = requests.get(self.target, timeout=10)
            
            # Check cookies
            for cookie in response.cookies:
                cookie_issues = []
                
                if not cookie.secure and self.target.startswith("https"):
                    cookie_issues.append("Missing Secure flag")
                
                if not getattr(cookie, 'httponly', False):
                    cookie_issues.append("Missing HttpOnly flag")
                
                if not getattr(cookie, 'samesite', None):
                    cookie_issues.append("Missing SameSite attribute")
                
                if cookie_issues:
                    self.results["session_management"].append({
                        "type": "Insecure Cookie",
                        "cookie_name": cookie.name,
                        "issues": cookie_issues,
                        "description": "Cookie security attributes missing",
                        "severity": "Medium"
                    })
            
        except Exception as e:
            self.log_output(f"Session management check error: {str(e)}")

    def check_input_validation(self):
        """Check for input validation issues"""
        try:
            self.log_output("Checking input validation...")
            
            # Test for basic XSS
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "';alert('XSS');//"
            ]
            
            # Look for forms
            response = requests.get(self.target, timeout=10)
            forms = re.findall(r'<form[^>]*>(.*?)</form>', response.text, re.DOTALL | re.IGNORECASE)
            
            if forms:
                self.log_output(f"Found {len(forms)} forms to test")
                
                # Test common parameters
                test_params = ["q", "search", "query", "term", "id", "user", "name", "email"]
                
                for param in test_params:
                    for payload in xss_payloads:
                        try:
                            test_url = f"{self.target}?{param}={payload}"
                            resp = requests.get(test_url, timeout=5)
                            
                            if payload in resp.text:
                                self.results["input_validation"].append({
                                    "type": "Reflected XSS",
                                    "parameter": param,
                                    "payload": payload,
                                    "url": test_url,
                                    "description": "User input reflected without proper sanitization",
                                    "severity": "High"
                                })
                                break
                        except:
                            continue
            
        except Exception as e:
            self.log_output(f"Input validation check error: {str(e)}")

    def check_server_configuration(self):
        """Check server configuration issues"""
        try:
            self.log_output("Checking server configuration...")
            
            # Check for common files
            common_files = [
                "/robots.txt", "/.htaccess", "/web.config", "/.env", "/config.php",
                "/phpinfo.php", "/info.php", "/test.php", "/backup.sql", "/dump.sql",
                "/.git/config", "/.svn/entries", "/composer.json", "/package.json"
            ]
            
            for file_path in common_files:
                try:
                    url = urljoin(self.target, file_path)
                    response = requests.get(url, timeout=5, allow_redirects=False)
                    
                    if response.status_code == 200:
                        self.results["configuration_issues"].append({
                            "type": "Sensitive File Accessible",
                            "file": file_path,
                            "url": url,
                            "description": "Sensitive file is publicly accessible",
                            "severity": "Medium" if file_path in ["/.env", "/config.php", "/backup.sql"] else "Low"
                        })
                        self.log_output(f"Found accessible file: {file_path}")
                        
                except:
                    continue
            
            # Check for directory listing
            try:
                response = requests.get(self.target, timeout=10)
                if "Index of /" in response.text or "Directory Listing" in response.text:
                    self.results["configuration_issues"].append({
                        "type": "Directory Listing Enabled",
                        "url": self.target,
                        "description": "Directory listing is enabled on the server",
                        "severity": "Low"
                    })
            except:
                pass
            
        except Exception as e:
            self.log_output(f"Server configuration check error: {str(e)}")

    def check_server_vulnerabilities(self):
        """Check for known server vulnerabilities"""
        try:
            self.log_output("Checking for server vulnerabilities...")
            
            response = requests.get(self.target, timeout=10)
            server_header = response.headers.get("Server", "").lower()
            
            # Check for outdated server versions
            vulnerable_patterns = {
                "apache/2.2": "Apache 2.2 has known vulnerabilities",
                "apache/2.0": "Apache 2.0 has known vulnerabilities", 
                "nginx/1.0": "Nginx 1.0 has known vulnerabilities",
                "iis/6.0": "IIS 6.0 has known vulnerabilities",
                "iis/7.0": "IIS 7.0 has known vulnerabilities"
            }
            
            for pattern, description in vulnerable_patterns.items():
                if pattern in server_header:
                    self.results["server_vulnerabilities"].append({
                        "type": "Outdated Server Version",
                        "server": server_header,
                        "description": description,
                        "severity": "High"
                    })
            
            # Check for common server misconfigurations
            test_paths = [
                "/server-status", "/server-info", "/nginx_status", "/status"
            ]
            
            for path in test_paths:
                try:
                    url = urljoin(self.target, path)
                    resp = requests.get(url, timeout=5)
                    if resp.status_code == 200 and ("apache" in resp.text.lower() or "nginx" in resp.text.lower()):
                        self.results["server_vulnerabilities"].append({
                            "type": "Server Status Page Accessible",
                            "url": url,
                            "description": "Server status page reveals sensitive information",
                            "severity": "Medium"
                        })
                except:
                    continue
            
        except Exception as e:
            self.log_output(f"Server vulnerability check error: {str(e)}")

    def scan(self):
        """Run comprehensive web vulnerability scan"""
        self.log_output(f"Starting web vulnerability scan on {self.target}")
        
        # Run different checks
        threads = []
        
        # SSL/TLS check
        thread1 = threading.Thread(target=self.check_ssl_configuration)
        threads.append(thread1)
        thread1.start()
        
        # Security headers check
        thread2 = threading.Thread(target=self.check_security_headers)
        threads.append(thread2)
        thread2.start()
        
        # Authentication issues
        thread3 = threading.Thread(target=self.check_authentication_issues)
        threads.append(thread3)
        thread3.start()
        
        # Session management
        thread4 = threading.Thread(target=self.check_session_management)
        threads.append(thread4)
        thread4.start()
        
        # Input validation
        thread5 = threading.Thread(target=self.check_input_validation)
        threads.append(thread5)
        thread5.start()
        
        # Server configuration
        thread6 = threading.Thread(target=self.check_server_configuration)
        threads.append(thread6)
        thread6.start()
        
        # Server vulnerabilities
        thread7 = threading.Thread(target=self.check_server_vulnerabilities)
        threads.append(thread7)
        thread7.start()
        
        # Wait for all threads to complete
        for thread in threads:
            thread.join()
        
        # Calculate summary
        total_issues = sum(len(issues) for issues in self.results.values())
        
        self.log_output(f"Web vulnerability scan completed:")
        self.log_output(f"- SSL vulnerabilities: {len(self.results['ssl_vulnerabilities'])}")
        self.log_output(f"- Security header issues: {len(self.results['security_headers'])}")
        self.log_output(f"- Information disclosure: {len(self.results['information_disclosure'])}")
        self.log_output(f"- Authentication issues: {len(self.results['authentication_issues'])}")
        self.log_output(f"- Session management issues: {len(self.results['session_management'])}")
        self.log_output(f"- Input validation issues: {len(self.results['input_validation'])}")
        self.log_output(f"- Configuration issues: {len(self.results['configuration_issues'])}")
        self.log_output(f"- Server vulnerabilities: {len(self.results['server_vulnerabilities'])}")
        self.log_output(f"- Total issues found: {total_issues}")
        
        return self.results

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 web_vulnerability_scanner.py <target_url>")
        sys.exit(1)
    
    target = sys.argv[1]
    scanner = WebVulnScanner(target)
    results = scanner.scan()
    
    # Output results in JSON format
    print("RESULTS_START")
    print(json.dumps(results, indent=2))
    print("RESULTS_END")

if __name__ == "__main__":
    main()